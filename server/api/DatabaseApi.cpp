/**
 * Pickle Rick API
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "DatabaseApi.h"
#include "Helpers.h"

using namespace server::helper;

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

DatabaseApi::DatabaseApi(std::shared_ptr<Pistache::Rest::Router> rtr) {
  router = rtr;
};

void DatabaseApi::init() { setupRoutes(); }

void DatabaseApi::setupRoutes() {
  using namespace Pistache::Rest;

  Routes::Post(*router, base + "/database/createContest",
               Routes::bind(&DatabaseApi::create_contest_handler, this));
  Routes::Post(*router, base + "/database/createSessionId",
               Routes::bind(&DatabaseApi::create_session_id_handler, this));
  Routes::Post(*router, base + "/database/createSolution",
               Routes::bind(&DatabaseApi::create_solution_handler, this));
  Routes::Post(*router, base + "/database/createTask",
               Routes::bind(&DatabaseApi::create_task_handler, this));
  Routes::Post(*router, base + "/database/createUser",
               Routes::bind(&DatabaseApi::createuser_handler, this));
  Routes::Get(*router, base + "/database/getContest",
              Routes::bind(&DatabaseApi::get_contest_handler, this));
  Routes::Get(*router, base + "/database/getLastSolution",
              Routes::bind(&DatabaseApi::get_last_solution_handler, this));
  Routes::Get(*router, base + "/database/getSessionId",
              Routes::bind(&DatabaseApi::get_session_id_handler, this));
  Routes::Get(*router, base + "/database/getSolution",
              Routes::bind(&DatabaseApi::get_solution_handler, this));
  Routes::Get(*router, base + "/database/getTask",
              Routes::bind(&DatabaseApi::get_task_handler, this));
  Routes::Post(*router, base + "/database/getUser",
               Routes::bind(&DatabaseApi::get_user_handler, this));
  Routes::Post(*router, base + "/database/updateSessionId",
               Routes::bind(&DatabaseApi::update_session_id_handler, this));

  // Default handler, called when a route is not found
  router->addCustomHandler(
      Routes::bind(&DatabaseApi::database_api_default_handler, this));
}

void DatabaseApi::create_contest_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the body param

  ContestData contestData;

  try {
    nlohmann::json::parse(request.body()).get_to(contestData);
    this->create_contest(contestData, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::create_session_id_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the body param

  UserSessionId userSessionId;

  try {
    nlohmann::json::parse(request.body()).get_to(userSessionId);
    this->create_session_id(userSessionId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::create_solution_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the body param

  SolutionData solutionData;

  try {
    nlohmann::json::parse(request.body()).get_to(solutionData);
    this->create_solution(solutionData, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::create_task_handler(const Pistache::Rest::Request &request,
                                      Pistache::Http::ResponseWriter response) {
  // Getting the body param

  TaskData taskData;

  try {
    nlohmann::json::parse(request.body()).get_to(taskData);
    this->create_task(taskData, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::createuser_handler(const Pistache::Rest::Request &request,
                                     Pistache::Http::ResponseWriter response) {
  // Getting the body param

  UserData userData;

  try {
    nlohmann::json::parse(request.body()).get_to(userData);
    this->createuser(userData, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::get_contest_handler(const Pistache::Rest::Request &request,
                                      Pistache::Http::ResponseWriter response) {
  // Getting the query params
  auto contestIdQuery = request.query().get("contest_id");
  Pistache::Optional<int32_t> contestId;
  if (!contestIdQuery.isEmpty()) {
    int32_t value;
    if (fromStringValue(contestIdQuery.get(), value)) {
      contestId = Pistache::Some(value);
    }
  }

  try {
    this->get_contest(contestId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::get_last_solution_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the query params
  auto taskIdQuery = request.query().get("task_id");
  Pistache::Optional<int32_t> taskId;
  if (!taskIdQuery.isEmpty()) {
    int32_t value;
    if (fromStringValue(taskIdQuery.get(), value)) {
      taskId = Pistache::Some(value);
    }
  }

  try {
    this->get_last_solution(taskId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::get_session_id_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the query params
  auto userIdQuery = request.query().get("user_id");
  Pistache::Optional<int32_t> userId;
  if (!userIdQuery.isEmpty()) {
    int32_t value;
    if (fromStringValue(userIdQuery.get(), value)) {
      userId = Pistache::Some(value);
    }
  }

  try {
    this->get_session_id(userId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::get_solution_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the query params
  auto solutionIdQuery = request.query().get("solution_id");
  Pistache::Optional<int32_t> solutionId;
  if (!solutionIdQuery.isEmpty()) {
    int32_t value;
    if (fromStringValue(solutionIdQuery.get(), value)) {
      solutionId = Pistache::Some(value);
    }
  }

  try {
    this->get_solution(solutionId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::get_task_handler(const Pistache::Rest::Request &request,
                                   Pistache::Http::ResponseWriter response) {
  // Getting the query params
  auto taskIdQuery = request.query().get("task_id");
  Pistache::Optional<int32_t> taskId;
  if (!taskIdQuery.isEmpty()) {
    int32_t value;
    if (fromStringValue(taskIdQuery.get(), value)) {
      taskId = Pistache::Some(value);
    }
  }

  try {
    this->get_task(taskId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::get_user_handler(const Pistache::Rest::Request &request,
                                   Pistache::Http::ResponseWriter response) {
  // Getting the body param

  UserData userData;

  try {
    nlohmann::json::parse(request.body()).get_to(userData);
    this->get_user(userData, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}
void DatabaseApi::update_session_id_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  // Getting the body param

  UserSessionId userSessionId;

  try {
    nlohmann::json::parse(request.body()).get_to(userSessionId);
    this->update_session_id(userSessionId, response);
  } catch (std::runtime_error &e) {
    // send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}

void DatabaseApi::database_api_default_handler(
    const Pistache::Rest::Request &request,
    Pistache::Http::ResponseWriter response) {
  response.send(Pistache::Http::Code::Not_Found,
                "The requested method does not exist");
}

}  // namespace api
}  // namespace server
}  // namespace openapitools
}  // namespace org
